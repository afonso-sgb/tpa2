# TPA2 - Technical Documentation Part 2: Common Module

**Course:** Computação Distribuída (Winter 2025-2026)  
**Module:** `common`  
**Date:** December 2025

---

## Table of Contents

1. [Module Overview](#module-overview)
2. [Package Structure](#package-structure)
3. [Configuration Classes](#configuration-classes)
4. [Model Classes](#model-classes)
5. [Utility Classes](#utility-classes)

---

## 1. Module Overview

### 1.1 Purpose

The `common` module contains **shared code** used by both `userapp` and `worker` modules:
- **Message models** for request/response communication
- **Payload classes** for different operation types
- **Spread message models** for worker-to-worker communication
- **Utility classes** for JSON serialization
- **Configuration constants** for RabbitMQ queues

### 1.2 Dependencies

```xml
<dependencies>
    <!-- JSON serialization -->
    <dependency>
        <groupId>com.google.code.gson</groupId>
        <artifactId>gson</artifactId>
        <version>2.10.1</version>
    </dependency>
    
    <!-- Logging -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
    </dependency>
</dependencies>
```

---

## 2. Package Structure

```
pt.isel.cd.common
├── config/
│   └── QueueConfig.java           # RabbitMQ queue configuration
├── model/
│   ├── RequestMessage.java        # Base request from client to worker
│   ├── ResponseMessage.java       # Base response from worker to client
│   ├── RequestType.java           # Enum: SEARCH, GET_FILE, GET_STATS
│   ├── ResponseStatus.java        # Enum: OK, NOT_FOUND, ERROR
│   ├── ResponseType.java          # Enum: SEARCH_RESULT, FILE_CONTENT, STATISTICS
│   ├── SearchPayload.java         # Payload for SEARCH requests
│   ├── SearchResultPayload.java   # Results for SEARCH operations
│   ├── FilePayload.java           # Payload for GET_FILE requests
│   ├── FileContentPayload.java    # File content response
│   ├── StatisticsPayload.java     # Aggregated statistics
│   ├── PartialStatsPayload.java   # Individual worker stats
│   ├── SpreadMessage.java         # Worker-to-worker messages
│   ├── SpreadMessageType.java     # Enum for Spread message types
│   ├── ElectionPayload.java       # Election initiation message
│   ├── VotePayload.java           # Vote message
│   ├── CoordinatorAnnouncePayload.java  # Election winner announcement
│   └── WorkerPresencePayload.java # Worker announcement
└── util/
    └── JsonUtil.java              # JSON serialization utilities
```

---

## 3. Configuration Classes

### 3.1 QueueConfig.java

**Purpose:** Centralize all RabbitMQ queue and connection configuration.

**Code:**
```java
package pt.isel.cd.common.config;

public class QueueConfig {
    
    // Main queue for work distribution to workers
    public static final String REQUESTS_QUEUE = "requests";
    
    // Prefix for client-specific response queues
    public static final String CLIENT_QUEUE_PREFIX = "client-";
    
    // TTL for client queues (milliseconds) - 5 minutes
    public static final int CLIENT_QUEUE_TTL = 300000;
    
    // Default RabbitMQ host
    public static final String DEFAULT_RABBITMQ_HOST = "localhost";
    
    // Default RabbitMQ port
    public static final int DEFAULT_RABBITMQ_PORT = 5672;
    
    private QueueConfig() {
        // Utility class - prevent instantiation
    }
}
```

**Design Decisions:**

1. **Single Work Queue:**
   - All requests go to one queue (`requests`)
   - RabbitMQ handles fair distribution to workers
   - Simpler than multiple queues or routing

2. **Temporary Client Queues:**
   - Each UserApp creates unique response queue (`client-<uuid>-resp`)
   - Auto-expires after 5 minutes of inactivity
   - Prevents queue accumulation

3. **Environment Variables:**
   - Defaults for local development
   - Can be overridden via environment for production

---

## 4. Model Classes

### 4.1 Request/Response Messages

#### RequestMessage.java

**Purpose:** Standard message format for all client→worker requests.

**Structure:**
```java
public class RequestMessage {
    private String requestId;      // Unique identifier (UUID)
    private RequestType type;      // SEARCH | GET_FILE | GET_STATS
    private String clientQueue;    // Where to send response
    private Object payload;        // Type-specific data
    
    // Constructor, getters, setters, equals, hashCode, toString
}
```

**Key Points:**

1. **requestId:** Correlation ID for matching responses
   - Generated by UserApp as `UUID.randomUUID().toString()`
   - Allows client to handle multiple concurrent requests
   
2. **type:** Determines how worker processes the request
   - `SEARCH`: Find files containing substrings
   - `GET_FILE`: Retrieve specific file content
   - `GET_STATS`: Trigger election and return statistics

3. **clientQueue:** Response routing
   - Worker publishes response to this queue
   - Format: `client-<uuid>-resp`
   - Unique per UserApp instance

4. **payload:** Type-specific data
   - Serialized as nested JSON object
   - Deserialized to correct type based on `RequestType`

#### ResponseMessage.java

**Purpose:** Standard message format for all worker→client responses.

**Structure:**
```java
public class ResponseMessage {
    private String requestId;      // Matches request
    private ResponseStatus status; // OK | NOT_FOUND | ERROR
    private ResponseType type;     // SEARCH_RESULT | FILE_CONTENT | STATISTICS
    private Object payload;        // Result data or error message
    
    // Constructor, getters, setters, equals, hashCode, toString
}
```

**Status Codes:**

| Status | Meaning | Use Case |
|--------|---------|----------|
| `OK` | Request successful | Normal response with data |
| `NOT_FOUND` | Resource doesn't exist | File not found in GET_FILE |
| `ERROR` | Processing failed | Exception during search, I/O error |

---

### 4.2 Payload Classes

#### SearchPayload.java

**Purpose:** Data for SEARCH requests.

```java
public class SearchPayload {
    private List<String> substrings;  // Terms to search for
    
    public SearchPayload(List<String> substrings) {
        this.substrings = substrings;
    }
    
    public List<String> getSubstrings() {
        return substrings;
    }
}
```

**Example:**
```json
{
  "requestId": "a1b2c3d4-...",
  "type": "SEARCH",
  "clientQueue": "client-xyz-resp",
  "payload": {
    "substrings": ["Docker", "GCP", "Java 21"]
  }
}
```

#### SearchResultPayload.java

**Purpose:** Results from SEARCH operations.

```java
public class SearchResultPayload {
    private Map<String, String> results;  // filename → file content
    
    public SearchResultPayload(Map<String, String> results) {
        this.results = results;
    }
    
    public Map<String, String> getResults() {
        return results;
    }
}
```

**Example:**
```json
{
  "requestId": "a1b2c3d4-...",
  "status": "OK",
  "type": "SEARCH_RESULT",
  "payload": {
    "results": {
      "email017.txt": "De: rodrigo.santiago@techteam.pt\n..."
    }
  }
}
```

#### FilePayload.java & FileContentPayload.java

**Purpose:** Request and response for file retrieval.

**Request:**
```java
public class FilePayload {
    private String filename;
    
    // Constructor, getter, setter
}
```

**Response:**
```java
public class FileContentPayload {
    private String filename;
    private String content;
    
    // Constructor, getters, setters
}
```

#### StatisticsPayload.java & PartialStatsPayload.java

**Purpose:** Aggregated and partial statistics.

**Aggregated (final result):**
```java
public class StatisticsPayload {
    private long totalRequests;       // Sum across all workers
    private long successfulRequests;  // Sum of successful
    private long failedRequests;      // Sum of failed
    private int workerCount;          // Number of workers
    
    // Constructor, getters, setters
}
```

**Partial (per worker):**
```java
public class PartialStatsPayload {
    private String workerId;          // Worker identifier
    private long totalRequests;       // This worker's total
    private long successfulRequests;  // This worker's successful
    private long failedRequests;      // This worker's failed
    
    // Constructor, getters, setters
}
```

---

### 4.3 Spread Communication Models

#### SpreadMessage.java

**Purpose:** Base message for worker-to-worker communication.

```java
public class SpreadMessage {
    private SpreadMessageType type;  // Message type
    private String senderId;         // Originating worker
    private long timestamp;          // When sent (milliseconds)
    private Object payload;          // Type-specific data
    
    public SpreadMessage(SpreadMessageType type, String senderId, Object payload) {
        this.type = type;
        this.senderId = senderId;
        this.payload = payload;
        this.timestamp = System.currentTimeMillis();
    }
    
    // Getters, setters
}
```

**Message Types:**
```java
public enum SpreadMessageType {
    WORKER_PRESENCE,      // Worker announces itself to group
    STATS_ELECTION,       // Initiate election for stats coordinator
    ELECTION_VOTE,        // Vote for coordinator
    COORDINATOR_ANNOUNCE, // Announce election winner
    STATS_REQUEST,        // Coordinator requests stats from worker
    STATS_RESPONSE        // Worker sends stats to coordinator
}
```

#### ElectionPayload.java

**Purpose:** Initiate leader election for statistics.

```java
public class ElectionPayload {
    private String candidateId;  // Worker initiating election
    private long electionEpoch;  // Unique election identifier
    private long uptime;         // Candidate's uptime (milliseconds)
    private String requestId;    // Original GET_STATS request ID
    private String clientQueue;  // Where to send final response
    
    // Constructor, getters, setters
}
```

**Key Fields:**

- **electionEpoch:** Globally unique timestamp to identify this election
  - Format: `currentTimeMillis() * 1000 + random(0-999)`
  - Prevents conflicts between simultaneous elections

- **uptime:** Used for priority comparison
  - Higher uptime = higher priority
  - Calculated as: `System.currentTimeMillis() - worker.startTime`

#### VotePayload.java

**Purpose:** Worker's vote in election.

```java
public class VotePayload {
    private String voterId;       // Worker casting vote
    private String votedFor;      // Candidate voted for
    private long electionEpoch;   // Which election
    private boolean accept;       // True if voting for initiator
    
    // Constructor, getters, setters
}
```

**Voting Logic:**
Each worker independently determines the best candidate:
1. Compare uptime (higher is better)
2. If equal, compare workerIds lexicographically
3. Vote for the winner

#### CoordinatorAnnouncePayload.java

**Purpose:** Broadcast election results.

```java
public class CoordinatorAnnouncePayload {
    private long electionEpoch;     // Which election
    private String coordinatorId;   // Winner
    private String requestId;       // Original request
    private String clientQueue;     // Where to send response
    
    // Constructor, getters, setters
}
```

**Why Broadcast?**
- Election initiator may not be the winner
- All workers need to know who won
- Winner needs request context to respond

---

## 5. Utility Classes

### 5.1 JsonUtil.java

**Purpose:** Centralize JSON serialization/deserialization with Gson.

**Full Implementation:**
```java
package pt.isel.cd.common.util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import pt.isel.cd.common.model.*;

public class JsonUtil {
    private static final Gson gson = new GsonBuilder()
            .setPrettyPrinting()
            .create();

    // Serialize object to JSON string
    public static String toJson(Object obj) {
        return gson.toJson(obj);
    }

    // Serialize object to byte array for RabbitMQ
    public static byte[] toJsonBytes(Object obj) {
        return toJson(obj).getBytes(StandardCharsets.UTF_8);
    }

    // Deserialize JSON string to object
    public static <T> T fromJson(String json, Class<T> clazz) {
        return gson.fromJson(json, clazz);
    }

    // Deserialize byte array to object
    public static <T> T fromJsonBytes(byte[] bytes, Class<T> clazz) {
        String json = new String(bytes, StandardCharsets.UTF_8);
        return fromJson(json, clazz);
    }

    // Parse RequestMessage and cast payload to correct type
    public static RequestMessage parseRequest(byte[] bytes) {
        RequestMessage msg = fromJsonBytes(bytes, RequestMessage.class);
        
        // Re-deserialize payload to correct type
        if (msg.getPayload() != null) {
            String payloadJson = toJson(msg.getPayload());
            Object typedPayload = switch (msg.getType()) {
                case SEARCH -> fromJson(payloadJson, SearchPayload.class);
                case GET_FILE -> fromJson(payloadJson, FilePayload.class);
                case GET_STATS -> null;  // No payload for GET_STATS
            };
            msg.setPayload(typedPayload);
        }
        
        return msg;
    }

    // Parse ResponseMessage and cast payload to correct type
    public static ResponseMessage parseResponse(byte[] bytes) {
        ResponseMessage msg = fromJsonBytes(bytes, ResponseMessage.class);
        
        // Re-deserialize payload to correct type
        if (msg.getPayload() != null && msg.getType() != null) {
            String payloadJson = toJson(msg.getPayload());
            Object typedPayload = switch (msg.getType()) {
                case SEARCH_RESULT -> fromJson(payloadJson, SearchResultPayload.class);
                case FILE_CONTENT -> fromJson(payloadJson, FileContentPayload.class);
                case STATISTICS -> fromJson(payloadJson, StatisticsPayload.class);
            };
            msg.setPayload(typedPayload);
        }
        
        return msg;
    }
}
```

**Why This Complexity?**

**Problem:** Gson deserializes nested `Object` fields as `LinkedTreeMap`:
```java
RequestMessage msg = gson.fromJson(json, RequestMessage.class);
Object payload = msg.getPayload();  // Actually a LinkedTreeMap!
SearchPayload search = (SearchPayload) payload;  // ClassCastException!
```

**Solution:** Re-serialize and deserialize with correct type:
1. Parse outer message
2. Extract payload as JSON string
3. Parse payload with correct class based on type field
4. Replace generic payload with typed object

**Benefits:**
- Type-safe payload access
- No casting needed in application code
- Centralized in one utility class

---

## 6. Design Patterns Used

### 6.1 Data Transfer Objects (DTOs)

All model classes are pure DTOs:
- **No business logic**
- **Only data + getters/setters**
- **Serializable to JSON**
- **Immutable or simple mutable**

### 6.2 Enum Types for Type Safety

Instead of strings:
```java
// Bad
String type = "SEARCH";

// Good
RequestType type = RequestType.SEARCH;
```

Benefits:
- Compile-time checking
- No typos
- IDE autocomplete
- Switch statement exhaustiveness

### 6.3 Builder Pattern (via Constructors)

All classes have full constructors:
```java
new RequestMessage(requestId, RequestType.SEARCH, clientQueue, payload);
```

Makes construction clear and prevents invalid states.

---

## 7. Message Examples

### 7.1 Complete SEARCH Request/Response

**Request:**
```json
{
  "requestId": "d648b71a-530c-4019-bc86-742afb605b4f",
  "type": "SEARCH",
  "clientQueue": "client-8bd836bc-fb27-4672-99d8-cc978e3ce3ef",
  "payload": {
    "substrings": ["Docker", "GCP"]
  }
}
```

**Response:**
```json
{
  "requestId": "d648b71a-530c-4019-bc86-742afb605b4f",
  "status": "OK",
  "type": "SEARCH_RESULT",
  "payload": {
    "results": {
      "email017.txt": "De: rodrigo.santiago@techteam.pt\nPara: manuela.afonso@techteam.pt\n..."
    }
  }
}
```

### 7.2 Election Message Sequence

**1. Election Initiation:**
```json
{
  "type": "STATS_ELECTION",
  "senderId": "worker-2",
  "timestamp": 1765302395620,
  "payload": {
    "candidateId": "worker-2",
    "electionEpoch": 1765302395620813,
    "uptime": 123456,
    "requestId": "abc123",
    "clientQueue": "client-xyz"
  }
}
```

**2. Vote:**
```json
{
  "type": "ELECTION_VOTE",
  "senderId": "worker-1",
  "timestamp": 1765302395625,
  "payload": {
    "voterId": "worker-1",
    "votedFor": "worker-2",
    "electionEpoch": 1765302395620813,
    "accept": true
  }
}
```

**3. Coordinator Announcement:**
```json
{
  "type": "COORDINATOR_ANNOUNCE",
  "senderId": "worker-2",
  "timestamp": 1765302395630,
  "payload": {
    "electionEpoch": 1765302395620813,
    "coordinatorId": "worker-2",
    "requestId": "abc123",
    "clientQueue": "client-xyz"
  }
}
```

---

**Document Version:** 1.0  
**Last Updated:** December 9, 2025  
**Next:** [Part 3 - UserApp Module](03-USERAPP-MODULE.md)
